// Generated by gencpp from file beginner_tutorials/obu_msg.msg
// DO NOT EDIT!


#ifndef BEGINNER_TUTORIALS_MESSAGE_OBU_MSG_H
#define BEGINNER_TUTORIALS_MESSAGE_OBU_MSG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace beginner_tutorials
{
template <class ContainerAllocator>
struct obu_msg_
{
  typedef obu_msg_<ContainerAllocator> Type;

  obu_msg_()
    : raw_data()
    , numofTrafficLights(0)
    , StationId(0)
    , createdUTC()
    , LastModified_UTC()
    , InterTime_UTC()
    , SpatTime_UTC()
    , refLat()
    , refLong()
    , refAlt()
    , validStraight(0)
    , maxLaneConfidenceStraight(0)
    , phaseIDStraight(0)
    , speedLimitStraight(0.0)
    , dis2StopLineStraight(0.0)
    , numOfSignalPhasesStraight(0)
    , signalStateStraight(0)
    , minEndTimeStraight(0.0)
    , maxEndTimeStraight(0.0)
    , likelyTimeStraight(0.0)
    , validLeft(0)
    , maxLaneConfidenceLeft(0)
    , phaseIDLeft(0)
    , speedLimitLeft(0.0)
    , dis2StopLineLeft(0.0)
    , numOfSignalPhasesLeft(0)
    , signalStateLeft(0)
    , minEndTimeLeft(0.0)
    , maxEndTimeLeft(0.0)
    , likelyTimeLeft(0.0)
    , validRight(0)
    , maxLaneConfidenceRight(0)
    , phaseIDRight(0)
    , speedLimitRight(0.0)
    , dis2StopLineRight(0.0)
    , numOfSignalPhasesRight(0)
    , signalStateRight(0)
    , minEndTimeRight(0.0)
    , maxEndTimeRight(0.0)
    , likelyTimeRight(0.0)  {
    }
  obu_msg_(const ContainerAllocator& _alloc)
    : raw_data(_alloc)
    , numofTrafficLights(0)
    , StationId(0)
    , createdUTC(_alloc)
    , LastModified_UTC(_alloc)
    , InterTime_UTC(_alloc)
    , SpatTime_UTC(_alloc)
    , refLat(_alloc)
    , refLong(_alloc)
    , refAlt(_alloc)
    , validStraight(0)
    , maxLaneConfidenceStraight(0)
    , phaseIDStraight(0)
    , speedLimitStraight(0.0)
    , dis2StopLineStraight(0.0)
    , numOfSignalPhasesStraight(0)
    , signalStateStraight(0)
    , minEndTimeStraight(0.0)
    , maxEndTimeStraight(0.0)
    , likelyTimeStraight(0.0)
    , validLeft(0)
    , maxLaneConfidenceLeft(0)
    , phaseIDLeft(0)
    , speedLimitLeft(0.0)
    , dis2StopLineLeft(0.0)
    , numOfSignalPhasesLeft(0)
    , signalStateLeft(0)
    , minEndTimeLeft(0.0)
    , maxEndTimeLeft(0.0)
    , likelyTimeLeft(0.0)
    , validRight(0)
    , maxLaneConfidenceRight(0)
    , phaseIDRight(0)
    , speedLimitRight(0.0)
    , dis2StopLineRight(0.0)
    , numOfSignalPhasesRight(0)
    , signalStateRight(0)
    , minEndTimeRight(0.0)
    , maxEndTimeRight(0.0)
    , likelyTimeRight(0.0)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _raw_data_type;
  _raw_data_type raw_data;

   typedef uint32_t _numofTrafficLights_type;
  _numofTrafficLights_type numofTrafficLights;

   typedef uint32_t _StationId_type;
  _StationId_type StationId;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _createdUTC_type;
  _createdUTC_type createdUTC;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _LastModified_UTC_type;
  _LastModified_UTC_type LastModified_UTC;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _InterTime_UTC_type;
  _InterTime_UTC_type InterTime_UTC;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _SpatTime_UTC_type;
  _SpatTime_UTC_type SpatTime_UTC;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _refLat_type;
  _refLat_type refLat;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _refLong_type;
  _refLong_type refLong;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _refAlt_type;
  _refAlt_type refAlt;

   typedef uint32_t _validStraight_type;
  _validStraight_type validStraight;

   typedef uint32_t _maxLaneConfidenceStraight_type;
  _maxLaneConfidenceStraight_type maxLaneConfidenceStraight;

   typedef uint32_t _phaseIDStraight_type;
  _phaseIDStraight_type phaseIDStraight;

   typedef float _speedLimitStraight_type;
  _speedLimitStraight_type speedLimitStraight;

   typedef float _dis2StopLineStraight_type;
  _dis2StopLineStraight_type dis2StopLineStraight;

   typedef uint32_t _numOfSignalPhasesStraight_type;
  _numOfSignalPhasesStraight_type numOfSignalPhasesStraight;

   typedef uint32_t _signalStateStraight_type;
  _signalStateStraight_type signalStateStraight;

   typedef float _minEndTimeStraight_type;
  _minEndTimeStraight_type minEndTimeStraight;

   typedef float _maxEndTimeStraight_type;
  _maxEndTimeStraight_type maxEndTimeStraight;

   typedef float _likelyTimeStraight_type;
  _likelyTimeStraight_type likelyTimeStraight;

   typedef uint32_t _validLeft_type;
  _validLeft_type validLeft;

   typedef uint32_t _maxLaneConfidenceLeft_type;
  _maxLaneConfidenceLeft_type maxLaneConfidenceLeft;

   typedef uint32_t _phaseIDLeft_type;
  _phaseIDLeft_type phaseIDLeft;

   typedef float _speedLimitLeft_type;
  _speedLimitLeft_type speedLimitLeft;

   typedef float _dis2StopLineLeft_type;
  _dis2StopLineLeft_type dis2StopLineLeft;

   typedef uint32_t _numOfSignalPhasesLeft_type;
  _numOfSignalPhasesLeft_type numOfSignalPhasesLeft;

   typedef uint32_t _signalStateLeft_type;
  _signalStateLeft_type signalStateLeft;

   typedef float _minEndTimeLeft_type;
  _minEndTimeLeft_type minEndTimeLeft;

   typedef float _maxEndTimeLeft_type;
  _maxEndTimeLeft_type maxEndTimeLeft;

   typedef float _likelyTimeLeft_type;
  _likelyTimeLeft_type likelyTimeLeft;

   typedef uint32_t _validRight_type;
  _validRight_type validRight;

   typedef uint32_t _maxLaneConfidenceRight_type;
  _maxLaneConfidenceRight_type maxLaneConfidenceRight;

   typedef uint32_t _phaseIDRight_type;
  _phaseIDRight_type phaseIDRight;

   typedef float _speedLimitRight_type;
  _speedLimitRight_type speedLimitRight;

   typedef float _dis2StopLineRight_type;
  _dis2StopLineRight_type dis2StopLineRight;

   typedef uint32_t _numOfSignalPhasesRight_type;
  _numOfSignalPhasesRight_type numOfSignalPhasesRight;

   typedef uint32_t _signalStateRight_type;
  _signalStateRight_type signalStateRight;

   typedef float _minEndTimeRight_type;
  _minEndTimeRight_type minEndTimeRight;

   typedef float _maxEndTimeRight_type;
  _maxEndTimeRight_type maxEndTimeRight;

   typedef float _likelyTimeRight_type;
  _likelyTimeRight_type likelyTimeRight;





  typedef boost::shared_ptr< ::beginner_tutorials::obu_msg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::beginner_tutorials::obu_msg_<ContainerAllocator> const> ConstPtr;

}; // struct obu_msg_

typedef ::beginner_tutorials::obu_msg_<std::allocator<void> > obu_msg;

typedef boost::shared_ptr< ::beginner_tutorials::obu_msg > obu_msgPtr;
typedef boost::shared_ptr< ::beginner_tutorials::obu_msg const> obu_msgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::beginner_tutorials::obu_msg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::beginner_tutorials::obu_msg_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace beginner_tutorials

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': False}
// {'beginner_tutorials': ['/home/lz/hello_rospy/src/beginner_tutorials/msg'], 'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::beginner_tutorials::obu_msg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::beginner_tutorials::obu_msg_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::beginner_tutorials::obu_msg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::beginner_tutorials::obu_msg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::beginner_tutorials::obu_msg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::beginner_tutorials::obu_msg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::beginner_tutorials::obu_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "c958469fe69d80e7b0b2ddbf9fa9f184";
  }

  static const char* value(const ::beginner_tutorials::obu_msg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xc958469fe69d80e7ULL;
  static const uint64_t static_value2 = 0xb0b2ddbf9fa9f184ULL;
};

template<class ContainerAllocator>
struct DataType< ::beginner_tutorials::obu_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "beginner_tutorials/obu_msg";
  }

  static const char* value(const ::beginner_tutorials::obu_msg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::beginner_tutorials::obu_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string raw_data	#原始数据备份\n\
uint32 numofTrafficLights    # 信号灯个数（单组）\n\
uint32 StationId    # 路口ID\n\
string createdUTC   # 第一次收到某一路口消息的时间戳(ms)\n\
string LastModified_UTC     # 每次更新此同一路口消息的时间戳 \n\
string InterTime_UTC    # UTC time stamp from traffic light controller\n\
string SpatTime_UTC     # UTC time stamp from the network e.g.uu\n\
string refLat   # 停车线坐标\n\
string refLong\n\
string refAlt\n\
\n\
uint32 validStraight #工作状态\n\
uint32 maxLaneConfidenceStraight \n\
uint32 phaseIDStraight # 相位 ID\n\
float32 speedLimitStraight # 当前车道限速\n\
float32 dis2StopLineStraight # 距停车线距离\n\
uint32 numOfSignalPhasesStraight # 信号灯可能状态数\n\
uint32 signalStateStraight # 信号灯状态\n\
float32 minEndTimeStraight\n\
float32 maxEndTimeStraight\n\
float32 likelyTimeStraight # 剩余时间\n\
\n\
uint32 validLeft\n\
uint32 maxLaneConfidenceLeft\n\
uint32 phaseIDLeft\n\
float32 speedLimitLeft\n\
float32 dis2StopLineLeft\n\
uint32 numOfSignalPhasesLeft\n\
uint32 signalStateLeft\n\
float32 minEndTimeLeft\n\
float32 maxEndTimeLeft\n\
float32 likelyTimeLeft\n\
\n\
uint32 validRight\n\
uint32 maxLaneConfidenceRight\n\
uint32 phaseIDRight\n\
float32 speedLimitRight\n\
float32 dis2StopLineRight\n\
uint32 numOfSignalPhasesRight\n\
uint32 signalStateRight\n\
float32 minEndTimeRight\n\
float32 maxEndTimeRight\n\
float32 likelyTimeRight\n\
";
  }

  static const char* value(const ::beginner_tutorials::obu_msg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::beginner_tutorials::obu_msg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.raw_data);
      stream.next(m.numofTrafficLights);
      stream.next(m.StationId);
      stream.next(m.createdUTC);
      stream.next(m.LastModified_UTC);
      stream.next(m.InterTime_UTC);
      stream.next(m.SpatTime_UTC);
      stream.next(m.refLat);
      stream.next(m.refLong);
      stream.next(m.refAlt);
      stream.next(m.validStraight);
      stream.next(m.maxLaneConfidenceStraight);
      stream.next(m.phaseIDStraight);
      stream.next(m.speedLimitStraight);
      stream.next(m.dis2StopLineStraight);
      stream.next(m.numOfSignalPhasesStraight);
      stream.next(m.signalStateStraight);
      stream.next(m.minEndTimeStraight);
      stream.next(m.maxEndTimeStraight);
      stream.next(m.likelyTimeStraight);
      stream.next(m.validLeft);
      stream.next(m.maxLaneConfidenceLeft);
      stream.next(m.phaseIDLeft);
      stream.next(m.speedLimitLeft);
      stream.next(m.dis2StopLineLeft);
      stream.next(m.numOfSignalPhasesLeft);
      stream.next(m.signalStateLeft);
      stream.next(m.minEndTimeLeft);
      stream.next(m.maxEndTimeLeft);
      stream.next(m.likelyTimeLeft);
      stream.next(m.validRight);
      stream.next(m.maxLaneConfidenceRight);
      stream.next(m.phaseIDRight);
      stream.next(m.speedLimitRight);
      stream.next(m.dis2StopLineRight);
      stream.next(m.numOfSignalPhasesRight);
      stream.next(m.signalStateRight);
      stream.next(m.minEndTimeRight);
      stream.next(m.maxEndTimeRight);
      stream.next(m.likelyTimeRight);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct obu_msg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::beginner_tutorials::obu_msg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::beginner_tutorials::obu_msg_<ContainerAllocator>& v)
  {
    s << indent << "raw_data: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.raw_data);
    s << indent << "numofTrafficLights: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.numofTrafficLights);
    s << indent << "StationId: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.StationId);
    s << indent << "createdUTC: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.createdUTC);
    s << indent << "LastModified_UTC: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.LastModified_UTC);
    s << indent << "InterTime_UTC: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.InterTime_UTC);
    s << indent << "SpatTime_UTC: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.SpatTime_UTC);
    s << indent << "refLat: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.refLat);
    s << indent << "refLong: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.refLong);
    s << indent << "refAlt: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.refAlt);
    s << indent << "validStraight: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.validStraight);
    s << indent << "maxLaneConfidenceStraight: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.maxLaneConfidenceStraight);
    s << indent << "phaseIDStraight: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.phaseIDStraight);
    s << indent << "speedLimitStraight: ";
    Printer<float>::stream(s, indent + "  ", v.speedLimitStraight);
    s << indent << "dis2StopLineStraight: ";
    Printer<float>::stream(s, indent + "  ", v.dis2StopLineStraight);
    s << indent << "numOfSignalPhasesStraight: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.numOfSignalPhasesStraight);
    s << indent << "signalStateStraight: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.signalStateStraight);
    s << indent << "minEndTimeStraight: ";
    Printer<float>::stream(s, indent + "  ", v.minEndTimeStraight);
    s << indent << "maxEndTimeStraight: ";
    Printer<float>::stream(s, indent + "  ", v.maxEndTimeStraight);
    s << indent << "likelyTimeStraight: ";
    Printer<float>::stream(s, indent + "  ", v.likelyTimeStraight);
    s << indent << "validLeft: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.validLeft);
    s << indent << "maxLaneConfidenceLeft: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.maxLaneConfidenceLeft);
    s << indent << "phaseIDLeft: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.phaseIDLeft);
    s << indent << "speedLimitLeft: ";
    Printer<float>::stream(s, indent + "  ", v.speedLimitLeft);
    s << indent << "dis2StopLineLeft: ";
    Printer<float>::stream(s, indent + "  ", v.dis2StopLineLeft);
    s << indent << "numOfSignalPhasesLeft: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.numOfSignalPhasesLeft);
    s << indent << "signalStateLeft: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.signalStateLeft);
    s << indent << "minEndTimeLeft: ";
    Printer<float>::stream(s, indent + "  ", v.minEndTimeLeft);
    s << indent << "maxEndTimeLeft: ";
    Printer<float>::stream(s, indent + "  ", v.maxEndTimeLeft);
    s << indent << "likelyTimeLeft: ";
    Printer<float>::stream(s, indent + "  ", v.likelyTimeLeft);
    s << indent << "validRight: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.validRight);
    s << indent << "maxLaneConfidenceRight: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.maxLaneConfidenceRight);
    s << indent << "phaseIDRight: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.phaseIDRight);
    s << indent << "speedLimitRight: ";
    Printer<float>::stream(s, indent + "  ", v.speedLimitRight);
    s << indent << "dis2StopLineRight: ";
    Printer<float>::stream(s, indent + "  ", v.dis2StopLineRight);
    s << indent << "numOfSignalPhasesRight: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.numOfSignalPhasesRight);
    s << indent << "signalStateRight: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.signalStateRight);
    s << indent << "minEndTimeRight: ";
    Printer<float>::stream(s, indent + "  ", v.minEndTimeRight);
    s << indent << "maxEndTimeRight: ";
    Printer<float>::stream(s, indent + "  ", v.maxEndTimeRight);
    s << indent << "likelyTimeRight: ";
    Printer<float>::stream(s, indent + "  ", v.likelyTimeRight);
  }
};

} // namespace message_operations
} // namespace ros

#endif // BEGINNER_TUTORIALS_MESSAGE_OBU_MSG_H
