# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from beginner_tutorials/obu_msg.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class obu_msg(genpy.Message):
  _md5sum = "c958469fe69d80e7b0b2ddbf9fa9f184"
  _type = "beginner_tutorials/obu_msg"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """string raw_data	#原始数据备份
uint32 numofTrafficLights    # 信号灯个数（单组）
uint32 StationId    # 路口ID
string createdUTC   # 第一次收到某一路口消息的时间戳(ms)
string LastModified_UTC     # 每次更新此同一路口消息的时间戳 
string InterTime_UTC    # UTC time stamp from traffic light controller
string SpatTime_UTC     # UTC time stamp from the network e.g.uu
string refLat   # 停车线坐标
string refLong
string refAlt

uint32 validStraight #工作状态
uint32 maxLaneConfidenceStraight 
uint32 phaseIDStraight # 相位 ID
float32 speedLimitStraight # 当前车道限速
float32 dis2StopLineStraight # 距停车线距离
uint32 numOfSignalPhasesStraight # 信号灯可能状态数
uint32 signalStateStraight # 信号灯状态
float32 minEndTimeStraight
float32 maxEndTimeStraight
float32 likelyTimeStraight # 剩余时间

uint32 validLeft
uint32 maxLaneConfidenceLeft
uint32 phaseIDLeft
float32 speedLimitLeft
float32 dis2StopLineLeft
uint32 numOfSignalPhasesLeft
uint32 signalStateLeft
float32 minEndTimeLeft
float32 maxEndTimeLeft
float32 likelyTimeLeft

uint32 validRight
uint32 maxLaneConfidenceRight
uint32 phaseIDRight
float32 speedLimitRight
float32 dis2StopLineRight
uint32 numOfSignalPhasesRight
uint32 signalStateRight
float32 minEndTimeRight
float32 maxEndTimeRight
float32 likelyTimeRight
"""
  __slots__ = ['raw_data','numofTrafficLights','StationId','createdUTC','LastModified_UTC','InterTime_UTC','SpatTime_UTC','refLat','refLong','refAlt','validStraight','maxLaneConfidenceStraight','phaseIDStraight','speedLimitStraight','dis2StopLineStraight','numOfSignalPhasesStraight','signalStateStraight','minEndTimeStraight','maxEndTimeStraight','likelyTimeStraight','validLeft','maxLaneConfidenceLeft','phaseIDLeft','speedLimitLeft','dis2StopLineLeft','numOfSignalPhasesLeft','signalStateLeft','minEndTimeLeft','maxEndTimeLeft','likelyTimeLeft','validRight','maxLaneConfidenceRight','phaseIDRight','speedLimitRight','dis2StopLineRight','numOfSignalPhasesRight','signalStateRight','minEndTimeRight','maxEndTimeRight','likelyTimeRight']
  _slot_types = ['string','uint32','uint32','string','string','string','string','string','string','string','uint32','uint32','uint32','float32','float32','uint32','uint32','float32','float32','float32','uint32','uint32','uint32','float32','float32','uint32','uint32','float32','float32','float32','uint32','uint32','uint32','float32','float32','uint32','uint32','float32','float32','float32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       raw_data,numofTrafficLights,StationId,createdUTC,LastModified_UTC,InterTime_UTC,SpatTime_UTC,refLat,refLong,refAlt,validStraight,maxLaneConfidenceStraight,phaseIDStraight,speedLimitStraight,dis2StopLineStraight,numOfSignalPhasesStraight,signalStateStraight,minEndTimeStraight,maxEndTimeStraight,likelyTimeStraight,validLeft,maxLaneConfidenceLeft,phaseIDLeft,speedLimitLeft,dis2StopLineLeft,numOfSignalPhasesLeft,signalStateLeft,minEndTimeLeft,maxEndTimeLeft,likelyTimeLeft,validRight,maxLaneConfidenceRight,phaseIDRight,speedLimitRight,dis2StopLineRight,numOfSignalPhasesRight,signalStateRight,minEndTimeRight,maxEndTimeRight,likelyTimeRight

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(obu_msg, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.raw_data is None:
        self.raw_data = ''
      if self.numofTrafficLights is None:
        self.numofTrafficLights = 0
      if self.StationId is None:
        self.StationId = 0
      if self.createdUTC is None:
        self.createdUTC = ''
      if self.LastModified_UTC is None:
        self.LastModified_UTC = ''
      if self.InterTime_UTC is None:
        self.InterTime_UTC = ''
      if self.SpatTime_UTC is None:
        self.SpatTime_UTC = ''
      if self.refLat is None:
        self.refLat = ''
      if self.refLong is None:
        self.refLong = ''
      if self.refAlt is None:
        self.refAlt = ''
      if self.validStraight is None:
        self.validStraight = 0
      if self.maxLaneConfidenceStraight is None:
        self.maxLaneConfidenceStraight = 0
      if self.phaseIDStraight is None:
        self.phaseIDStraight = 0
      if self.speedLimitStraight is None:
        self.speedLimitStraight = 0.
      if self.dis2StopLineStraight is None:
        self.dis2StopLineStraight = 0.
      if self.numOfSignalPhasesStraight is None:
        self.numOfSignalPhasesStraight = 0
      if self.signalStateStraight is None:
        self.signalStateStraight = 0
      if self.minEndTimeStraight is None:
        self.minEndTimeStraight = 0.
      if self.maxEndTimeStraight is None:
        self.maxEndTimeStraight = 0.
      if self.likelyTimeStraight is None:
        self.likelyTimeStraight = 0.
      if self.validLeft is None:
        self.validLeft = 0
      if self.maxLaneConfidenceLeft is None:
        self.maxLaneConfidenceLeft = 0
      if self.phaseIDLeft is None:
        self.phaseIDLeft = 0
      if self.speedLimitLeft is None:
        self.speedLimitLeft = 0.
      if self.dis2StopLineLeft is None:
        self.dis2StopLineLeft = 0.
      if self.numOfSignalPhasesLeft is None:
        self.numOfSignalPhasesLeft = 0
      if self.signalStateLeft is None:
        self.signalStateLeft = 0
      if self.minEndTimeLeft is None:
        self.minEndTimeLeft = 0.
      if self.maxEndTimeLeft is None:
        self.maxEndTimeLeft = 0.
      if self.likelyTimeLeft is None:
        self.likelyTimeLeft = 0.
      if self.validRight is None:
        self.validRight = 0
      if self.maxLaneConfidenceRight is None:
        self.maxLaneConfidenceRight = 0
      if self.phaseIDRight is None:
        self.phaseIDRight = 0
      if self.speedLimitRight is None:
        self.speedLimitRight = 0.
      if self.dis2StopLineRight is None:
        self.dis2StopLineRight = 0.
      if self.numOfSignalPhasesRight is None:
        self.numOfSignalPhasesRight = 0
      if self.signalStateRight is None:
        self.signalStateRight = 0
      if self.minEndTimeRight is None:
        self.minEndTimeRight = 0.
      if self.maxEndTimeRight is None:
        self.maxEndTimeRight = 0.
      if self.likelyTimeRight is None:
        self.likelyTimeRight = 0.
    else:
      self.raw_data = ''
      self.numofTrafficLights = 0
      self.StationId = 0
      self.createdUTC = ''
      self.LastModified_UTC = ''
      self.InterTime_UTC = ''
      self.SpatTime_UTC = ''
      self.refLat = ''
      self.refLong = ''
      self.refAlt = ''
      self.validStraight = 0
      self.maxLaneConfidenceStraight = 0
      self.phaseIDStraight = 0
      self.speedLimitStraight = 0.
      self.dis2StopLineStraight = 0.
      self.numOfSignalPhasesStraight = 0
      self.signalStateStraight = 0
      self.minEndTimeStraight = 0.
      self.maxEndTimeStraight = 0.
      self.likelyTimeStraight = 0.
      self.validLeft = 0
      self.maxLaneConfidenceLeft = 0
      self.phaseIDLeft = 0
      self.speedLimitLeft = 0.
      self.dis2StopLineLeft = 0.
      self.numOfSignalPhasesLeft = 0
      self.signalStateLeft = 0
      self.minEndTimeLeft = 0.
      self.maxEndTimeLeft = 0.
      self.likelyTimeLeft = 0.
      self.validRight = 0
      self.maxLaneConfidenceRight = 0
      self.phaseIDRight = 0
      self.speedLimitRight = 0.
      self.dis2StopLineRight = 0.
      self.numOfSignalPhasesRight = 0
      self.signalStateRight = 0
      self.minEndTimeRight = 0.
      self.maxEndTimeRight = 0.
      self.likelyTimeRight = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.raw_data
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_2I().pack(_x.numofTrafficLights, _x.StationId))
      _x = self.createdUTC
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.LastModified_UTC
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.InterTime_UTC
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.SpatTime_UTC
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.refLat
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.refLong
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.refAlt
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_3I2f2I3f3I2f2I3f3I2f2I3f().pack(_x.validStraight, _x.maxLaneConfidenceStraight, _x.phaseIDStraight, _x.speedLimitStraight, _x.dis2StopLineStraight, _x.numOfSignalPhasesStraight, _x.signalStateStraight, _x.minEndTimeStraight, _x.maxEndTimeStraight, _x.likelyTimeStraight, _x.validLeft, _x.maxLaneConfidenceLeft, _x.phaseIDLeft, _x.speedLimitLeft, _x.dis2StopLineLeft, _x.numOfSignalPhasesLeft, _x.signalStateLeft, _x.minEndTimeLeft, _x.maxEndTimeLeft, _x.likelyTimeLeft, _x.validRight, _x.maxLaneConfidenceRight, _x.phaseIDRight, _x.speedLimitRight, _x.dis2StopLineRight, _x.numOfSignalPhasesRight, _x.signalStateRight, _x.minEndTimeRight, _x.maxEndTimeRight, _x.likelyTimeRight))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.raw_data = str[start:end].decode('utf-8')
      else:
        self.raw_data = str[start:end]
      _x = self
      start = end
      end += 8
      (_x.numofTrafficLights, _x.StationId,) = _get_struct_2I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.createdUTC = str[start:end].decode('utf-8')
      else:
        self.createdUTC = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.LastModified_UTC = str[start:end].decode('utf-8')
      else:
        self.LastModified_UTC = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.InterTime_UTC = str[start:end].decode('utf-8')
      else:
        self.InterTime_UTC = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.SpatTime_UTC = str[start:end].decode('utf-8')
      else:
        self.SpatTime_UTC = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.refLat = str[start:end].decode('utf-8')
      else:
        self.refLat = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.refLong = str[start:end].decode('utf-8')
      else:
        self.refLong = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.refAlt = str[start:end].decode('utf-8')
      else:
        self.refAlt = str[start:end]
      _x = self
      start = end
      end += 120
      (_x.validStraight, _x.maxLaneConfidenceStraight, _x.phaseIDStraight, _x.speedLimitStraight, _x.dis2StopLineStraight, _x.numOfSignalPhasesStraight, _x.signalStateStraight, _x.minEndTimeStraight, _x.maxEndTimeStraight, _x.likelyTimeStraight, _x.validLeft, _x.maxLaneConfidenceLeft, _x.phaseIDLeft, _x.speedLimitLeft, _x.dis2StopLineLeft, _x.numOfSignalPhasesLeft, _x.signalStateLeft, _x.minEndTimeLeft, _x.maxEndTimeLeft, _x.likelyTimeLeft, _x.validRight, _x.maxLaneConfidenceRight, _x.phaseIDRight, _x.speedLimitRight, _x.dis2StopLineRight, _x.numOfSignalPhasesRight, _x.signalStateRight, _x.minEndTimeRight, _x.maxEndTimeRight, _x.likelyTimeRight,) = _get_struct_3I2f2I3f3I2f2I3f3I2f2I3f().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.raw_data
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_2I().pack(_x.numofTrafficLights, _x.StationId))
      _x = self.createdUTC
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.LastModified_UTC
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.InterTime_UTC
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.SpatTime_UTC
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.refLat
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.refLong
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.refAlt
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_3I2f2I3f3I2f2I3f3I2f2I3f().pack(_x.validStraight, _x.maxLaneConfidenceStraight, _x.phaseIDStraight, _x.speedLimitStraight, _x.dis2StopLineStraight, _x.numOfSignalPhasesStraight, _x.signalStateStraight, _x.minEndTimeStraight, _x.maxEndTimeStraight, _x.likelyTimeStraight, _x.validLeft, _x.maxLaneConfidenceLeft, _x.phaseIDLeft, _x.speedLimitLeft, _x.dis2StopLineLeft, _x.numOfSignalPhasesLeft, _x.signalStateLeft, _x.minEndTimeLeft, _x.maxEndTimeLeft, _x.likelyTimeLeft, _x.validRight, _x.maxLaneConfidenceRight, _x.phaseIDRight, _x.speedLimitRight, _x.dis2StopLineRight, _x.numOfSignalPhasesRight, _x.signalStateRight, _x.minEndTimeRight, _x.maxEndTimeRight, _x.likelyTimeRight))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.raw_data = str[start:end].decode('utf-8')
      else:
        self.raw_data = str[start:end]
      _x = self
      start = end
      end += 8
      (_x.numofTrafficLights, _x.StationId,) = _get_struct_2I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.createdUTC = str[start:end].decode('utf-8')
      else:
        self.createdUTC = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.LastModified_UTC = str[start:end].decode('utf-8')
      else:
        self.LastModified_UTC = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.InterTime_UTC = str[start:end].decode('utf-8')
      else:
        self.InterTime_UTC = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.SpatTime_UTC = str[start:end].decode('utf-8')
      else:
        self.SpatTime_UTC = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.refLat = str[start:end].decode('utf-8')
      else:
        self.refLat = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.refLong = str[start:end].decode('utf-8')
      else:
        self.refLong = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.refAlt = str[start:end].decode('utf-8')
      else:
        self.refAlt = str[start:end]
      _x = self
      start = end
      end += 120
      (_x.validStraight, _x.maxLaneConfidenceStraight, _x.phaseIDStraight, _x.speedLimitStraight, _x.dis2StopLineStraight, _x.numOfSignalPhasesStraight, _x.signalStateStraight, _x.minEndTimeStraight, _x.maxEndTimeStraight, _x.likelyTimeStraight, _x.validLeft, _x.maxLaneConfidenceLeft, _x.phaseIDLeft, _x.speedLimitLeft, _x.dis2StopLineLeft, _x.numOfSignalPhasesLeft, _x.signalStateLeft, _x.minEndTimeLeft, _x.maxEndTimeLeft, _x.likelyTimeLeft, _x.validRight, _x.maxLaneConfidenceRight, _x.phaseIDRight, _x.speedLimitRight, _x.dis2StopLineRight, _x.numOfSignalPhasesRight, _x.signalStateRight, _x.minEndTimeRight, _x.maxEndTimeRight, _x.likelyTimeRight,) = _get_struct_3I2f2I3f3I2f2I3f3I2f2I3f().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_3I2f2I3f3I2f2I3f3I2f2I3f = None
def _get_struct_3I2f2I3f3I2f2I3f3I2f2I3f():
    global _struct_3I2f2I3f3I2f2I3f3I2f2I3f
    if _struct_3I2f2I3f3I2f2I3f3I2f2I3f is None:
        _struct_3I2f2I3f3I2f2I3f3I2f2I3f = struct.Struct("<3I2f2I3f3I2f2I3f3I2f2I3f")
    return _struct_3I2f2I3f3I2f2I3f3I2f2I3f
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
